//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:<#= Environment.Version #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#= ns #>
{
    using System;

    using GW2NET.Common;
    using <#= targetBaseType.Namespace #>;
	using <#= sourceType #> = <#= sourceTypeFullName #>;

    public sealed partial class <#= targetBaseType.Name #>Converter : IConverter<<#= sourceType #>, <#= targetBaseType.Name #>>
	{
	    private readonly ITypeConverterFactory<<#= sourceType #>, <#= targetBaseType.Name #>> converterFactory;

		<#= constructorVisibility #> <#= targetBaseType.Name #>Converter(ITypeConverterFactory<<#= sourceType #>, <#= targetBaseType.Name #>> converterFactory)
		{
		    if (converterFactory == null)
    		{
    		    throw new ArgumentNullException("converterFactory");
    		}

		    this.converterFactory = converterFactory;
		}

		 /// <inheritdoc />
        <#= targetBaseType.Name #> IConverter<<#= sourceType #>, <#= targetBaseType.Name #>>.Convert(<#= sourceType #> value, object state)
		{
		    if (value == null)
    		{
    		    throw new ArgumentNullException("value");
    		}

			string discriminator = <#= string.Format(discriminator, "value") #>;
			var converter = this.converterFactory.Create(discriminator);
			var entity = converter.Convert(value, value);
			this.Merge(entity, value, state);
			return entity;
		}

		// Implement this method in a buddy class to set properties that are specific to '<#= targetBaseType.Name #>' (if any)
    	partial void Merge(<#= targetBaseType.Name #> entity, <#= sourceType #> dto, object state);

		/*
		// Use this template
		public partial class <#= targetBaseType.Name #>Converter
		{
		    partial void Merge(<#= targetBaseType.Name #> entity, <#= sourceType #> dto, object state)
			{
			    throw new NotImplementedException();
			}
		}
		*/
	}

<#
    var targetTypes = GetSubTypes(targetBaseType);
    foreach (var targetType in targetTypes)
    {
#>
#region <#= targetType.Name #>
    /// <summary>Converts objects of type <see cref="<#= sourceType #>"/> to objects of type <see cref="<#= targetType.Name #>"/>.</summary>
    public sealed partial class <#= targetType.Name #>Converter : IConverter<<#= sourceType #>, <#= targetBaseType.Name #>>
    {
	    /// <inheritdoc />
        public <#= targetBaseType.Name #> Convert(<#= sourceType #> value, object state)
        {
    		var entity = new <#= targetType.Name #>();
            this.Merge(entity, value, state);
    		return entity;
        }

    	// Implement this method in a buddy class to set properties that are specific to '<#= targetType.Name #>' (if any)
    	partial void Merge(<#= targetType.Name #> entity, <#= sourceType #> dto, object state);

		/*
		// Use this template
		public partial class <#= targetType.Name #>Converter
		{
		    partial void Merge(<#= targetType.Name #> entity, <#= sourceType #> dto, object state)
			{
			    throw new NotImplementedException();
			}
		}
		*/
    }
#endregion

<#
    }
#>
}
<#+

    public Type[] GetSubTypes(Type baseType)
    {
        return baseType.Assembly.ExportedTypes.Where(t => t.BaseType == baseType && !t.IsAbstract).ToArray();
    }
#>